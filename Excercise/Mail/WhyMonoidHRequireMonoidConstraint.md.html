<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>WhyMonoidHRequireMonoidConstraint</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <style type="text/css">blockquote p::before{
content: "";
display: block;
position: absolute;
top: 0;
bottom: 0;
left: 0;
width: 4px;
border-radius: 8px;
background: #c8ccd0;
}
blockquote{
color:#535a60;
padding:.8em .8em .8em 1em;
position: relative;
}
</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Dear Conal,</p>
<p>Sorry for late response. I think I finally understand your
question.</p>
<blockquote>
<p>In your CommMonoidH class, what purpose is served by
the P-comm, comm-monoidₘ and comm-monoidₙ fields? In other words, what
value would be lost if you eliminated them? Likewise, in
your MonoidH class, what purpose is served by the third and fourth
fields (monoidₘ and monoidₙ)?</p>
</blockquote>
<h3 id="monoidh-class"><code>MonoidH</code> class</h3>
<p>If <code>monoidₘ</code> is constrained, but <code>monoidₙ</code> is
<em>not</em> constrainted, then even if <code>f</code> satisfied
<code>MonoidH</code> property, f does not preserve identity property.
Proof:</p>
<ul>
<li>Given <code>a</code> in <em>monoidₘ</em>, we have:
<code>eₘ ∙ₘ a ≡ a ≡ a ∙ₘ eₘ</code></li>
<li>Applying f to each of them and then use <code>P-∙</code> property,
we have:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    f a                       ≡ f a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    f <span class="ot">(</span>a ∙ₘ eₘ<span class="ot">)</span> ≡ f a ∙ₙ f eₘ ≡ f a ∙ₙ eₙ</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    f <span class="ot">(</span>eₘ ∙ₘ a<span class="ot">)</span> ≡ f eₘ ∙ₙ f a ≡ eₙ ∙ₙ f a</span></code></pre></div>
<ul>
<li>But since <code>monoidₙ</code> is not constrained, in general
<code>f a ∙ₙ eₙ ≢ f a ≢ eₙ ∙ₙ f a</code>.</li>
<li>So from single value <code>a</code> in <code>M</code>, there are
there different way transform it through <code>f</code>, a faulty monoid
morphism, each each of them give a different result.</li>
</ul>
<p>Similar with <code>∙-assoc</code> property, we might get two
different results from transforming <code>a ∙ₘ b ∙ₘ c</code> through f
since <code>(f a ∙ₙ f b) ∙ₙ f c ≢ f a ∙ₙ (f b ∙ₙ f c)</code>.</p>
<p>So that even though <code>f</code> satisfied two properties of the
faulty <code>MonoidH</code>, it does not preserve monoid structure.</p>
<p>So what if <code>monoidₘ</code> is not constrained? In this case,
<code>M</code> has no structure, so there is no point of saying that
<code>f</code> preserve any structure.</p>
<h3 id="commmonoidh-class"><code>CommMonoidH</code> class</h3>
<p>Similar to <code>MonoidH</code>, given <code>P-comm</code> is
proved.</p>
<ul>
<li>If <code>comm-monoidₘ</code> is not constrained, then there is no
(communicative) structure to preserve.</li>
<li>If <code>comm-monoidₙ</code> is not constrained, we can not say
<code>f</code> preserve communicative properties since given
<code>a ∙ₘ b</code> in <code>M</code>, we got different results
<code>f a ∙ₙ f b ≢ f b ∙ₙ f a</code> after transformed by
<code>f</code>.</li>
</ul>
<blockquote>
<p>P.S. Please let me know if you have a preference for my emails to be
rendered, raw Markdown, rendered and raw as an attachment, or some other
variation.</p>
</blockquote>
<p>Thanks, I have no preference and you can use any style that works
best for you.</p>
<p>Best Regards,</p>
<p>Thong</p>
<p>Dear Conal,</p>
<blockquote>
<p>I think you are trying to argue that the existence of a raw monoid
homomorphism from a (law-abiding) monoid does not imply that the
homomorphism’s target obeys the monoid laws. Am I accurately
understanding the nature of your claim?</p>
</blockquote>
<p>Yes, that’s exactly what I was trying to prove.</p>
<blockquote>
<p>I think the shape of your argument here (leading to the third bullet
point above) is that if P ⇒ Q then ¬ P ⇒ ¬ Q, which you probably realize
is not generally valid. (Not all sufficient conditions are necessary
conditions.)</p>
</blockquote>
<p>Thank you for pointed that out. Now I see the error with my
proof.</p>
<blockquote>
<p>Is your claim above somehow related to a purpose you see being served
by including the Monoid constraints in the MonoidH class (and similarly
for CommMonoidH)? &gt; In your CommMonoidH class, what purpose is served
by the P-comm, comm-monoidₘ and comm-monoidₙ fields? In other words,
what value would be lost if you eliminated them? Likewise, in
your MonoidH class, what purpose is served by the third and fourth
fields (monoidₘ and monoidₙ)?</p>
</blockquote>
<p>Because you asked <em>“what value would be lost if you eliminated
them?”</em>, I want to show that without <code>Monoid</code> constraints
in <code>MonoidH</code> or similarly with <code>CommMonoidH</code>, the
homomorphisms would <em>not</em> be the morphisms that preserve
(monoid/communicative monoid) structure. That’s why I need to include it
in the definition of those homomorphisms.</p>
<p>I apologize if there was any confusion caused by my misunderstanding
of your request or if my English is not clear. As a non-native speaker,
I sometimes or struggle to express myself clearly in writing.</p>
<p>Sincerely, Thong</p>
</body>
</html>
